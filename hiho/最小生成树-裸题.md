## 最小生成树-裸题
[题目链接](http://hihocoder.com/problemset/problem/1097)  
## 最小生成树一·Prim算法
时间限制:10000ms  
单点时限:1000ms  
内存限制:256MB  
## 描述  
最近，小Hi很喜欢玩的一款游戏模拟城市开放出了新Mod，在这个Mod中，玩家可以拥有不止一个城市了！  

但是，问题也接踵而来——小Hi现在手上拥有N座城市，且已知这N座城市中任意两座城市之间建造道路所需要的费

用，小Hi希望知道，最少花费多少就可以使得任意两座城市都可以通过所建造的道路互相到达（假设有A、B、C三座

城市，只需要在AB之间和BC之间建造道路，那么AC之间也是可以通过这两条道路连通的）。

## 输入
每个测试点（输入文件）有且仅有一组测试数据。

在一组测试数据中：

第1行为1个整数N，表示小Hi拥有的城市数量。

接下来的N行，为一个N*N的矩阵A，描述任意两座城市之间建造道路所需要的费用，其中第i行第j个数为Aij，表示第i座城市和第j座城市之间建造道路所需要的费用。

对于100%的数据，满足N<=10^3，对于任意i，满足Aii=0，对于任意i, j满足Aij=Aji, 0<Aij<10^4.

## 输出
对于每组测试数据，输出1个整数Ans，表示为了使任意两座城市都可以通过所建造的道路互相到达至少需要的建造费用。

## 样例输入
5  
0 1005 6963 392 1182   
1005 0 1599 4213 1451    
6963 1599 0 9780 2789   
392 4213 9780 0 5236   
1182 1451 2789 5236 0   
## 样例输出
4178  
## 思路
个人解析 prim算法：一共有n个顶点，先取第一个点，从第一个点开始判断，这个点所连接其他顶点的边，边的权重，取最小的且这个点没有被取，并连接它。这样就有两个顶点了，
**这个过程中用到一个数组lowcoat[]，记录这些边的权重。数组下标代表着其他点**。紧接着我们取到第二个点之后，需要判断第二点连接其他顶点的边的权重，并把它更新到lowcoat[]数组。
为什么要更新，因为我们需要每次把最小的权重边所连接的点加入到 这颗树里。


### AC代码
    #include<iostream>
    using namespace std;
    int gp[1005][1005];
    int lowcost[1005],vset[1005];
    
    
    int main()
    {
    	int n;
    	cin>>n;
    	for(int i=0;i<n;i++)
    		for(int j=0;j<n;j++)
    			cin>>gp[i][j];
    	int v,i,j,k,min;
    	long sum;
    	v=0;
    	for(i=0;i<n;i++)
    	{
    		lowcost[i]=gp[v][i];
    		vset[i]=0;
    	}
    	vset[v]=1;
    	sum=0;
    	
    	for(i=0;i<n-1;i++)
    	{
    		
    		min=10009;
    		for(j=0;j<n;j++)
    		{
    			if(vset[j]==0&&lowcost[j]<min)
    			{
    				min=lowcost[j];
    				k=j;
    			}
    		}
    		vset[k]=1;
    		v=k;
    		sum+=min;
    		for(j=0;j<n;j++)
    		{
    			if(vset[j]==0&&gp[v][j]<lowcost[j])
    				lowcost[j]=gp[v][j];
    		}
    		
    		
    	}
    	cout<<sum<<endl;		
    	
    	return 0;
    } 