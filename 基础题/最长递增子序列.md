# 1134 最长递增子序列  
基准时间限制：1 秒 空间限制：131072 KB  
给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）  
例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。
## Input
第1行：1个数N，N为序列的长度(2 <= N <= 50000)
第2 - N + 1行：每行1个数，对应序列的元素(-10^9 <= S[i] <= 10^9)
## Output
输出最长递增子序列的长度。
## Input示例
8
5
1
6
8
2
4
5
10
## Output示例
5

## 思路
[详细思路请点我](http://blog.csdn.net/shuangde800/article/details/7474903)  
先说说**lower_bound()**函数吧  
lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value 的值[1]  。该函数为C++ STL内的函数。  
这题网上n^2的算法过不了，nlogn的能过。  
> 具体举个例子d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}  
> 一步一步找出LIS
> 首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1
> 
> 然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1
> 
> 接着，d[3] = 5，d[3]>B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2
> 
> 再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2
> 
> 继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。
> 
> 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3
> 
> 第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了
> 
> 第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。
> 
> 最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。
> 
> 于是我们知道了LIS的长度为5。

## 代码
    #include <stdio.h>
    #include <algorithm>
    #include <iostream>
    using namespace std;
    
    int dp[50050];
    int main(){
    	int a,n,i,j;
    	scanf("%d",&n);//输入n;
    	fill(dp,dp+n,1e9);//从dp[0]~dp[n]填充值1e9；
    	for(i = 0;i < n; i++){
    		scanf("%d",&a);//输入序列
    		*lower_bound(dp , dp+n, a) = a;//使用STL中的lower_bound函数。
    	}
    	printf("%d\n",lower_bound(dp,dp+n,1e9) - dp);//按从小到大，1e9最多能插入数组dp的哪个位置  
    	return 0;
    }